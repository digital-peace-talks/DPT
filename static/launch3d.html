<!DOCTYPE html>
<html>
	<head>
	<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

	<title>Babylon.js sample code</title>

	<!-- Babylon.js -->
	<script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
	<!--
	<script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.6.2/dat.gui.min.js"></script>
	<script src="https://preview.babylonjs.com/ammo.js"></script>
	<script src="https://preview.babylonjs.com/cannon.js"></script>
	<script src="https://preview.babylonjs.com/Oimo.js"></script>
	<script src="https://preview.babylonjs.com/gltf_validator.js"></script>
	<script src="https://preview.babylonjs.com/earcut.min.js"></script>
	<script src="https://preview.babylonjs.com/inspector/babylon.inspector.bundle.js"></script>
	<script src="https://preview.babylonjs.com/materialsLibrary/babylonjs.materials.min.js"></script>
	<script src="https://preview.babylonjs.com/proceduralTexturesLibrary/babylonjs.proceduralTextures.min.js"></script>
	-->
	<script src="https://preview.babylonjs.com/babylon.js"></script>
	<!--
	<script src="https://preview.babylonjs.com/postProcessesLibrary/babylonjs.postProcess.min.js"></script>
	<script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"/>
	<script src="https://preview.babylonjs.com/serializers/babylonjs.serializers.min.js"></script>
	-->
	<script src="https://preview.babylonjs.com/gui/babylon.gui.min.js"></script>

	<style>
		@font-face {
			font-family: 'AldoSemiBold';
			src: url('/font.ttf') format('truetype');
		}
		html, body {
			font-family: 'AldoSemiBold';
			overflow: hidden;
			width: 100%;
			height: 100%;
			margin: 0;
			padding: 0;
		}

		#renderCanvas {
			width: 100%;
			height: 100%;
			touch-action: none;
		}
	</style>
	</head>
	<body>
	<canvas id="renderCanvas" ></canvas>
	<script>
		var canvas = document.getElementById("renderCanvas");
		
		function wrapText(context, text, x, y, maxWidth, lineHeight) {
			var words = text.split(' ');
			var line = '';
			for(var n = 0; n < words.length; n++) {
				var testLine = line + words[n] + ' ';
				var metrics = context.measureText(testLine);
				var testWidth = metrics.width;
				if (testWidth > maxWidth && n > 0) {
					context.fillText(line, x, y);
					line = words[n] + ' ';
					y += lineHeight;
				} else {
					line = testLine;
				}
			}
			context.fillText(line, x, y);
		}

		function textBlock(x, y, z, name, text) {
			//Set width an height for plane
			var planeWidth = 4.8;
			var planeHeight = 3.2; //10;

			//Create plane
			var plane = BABYLON.MeshBuilder.CreatePlane(name, {width:planeWidth, height:planeHeight}, currentScene);
			plane.dpt = JSON.parse(name);

			//Set width and height for dynamic texture using same multiplier
			var DTWidth = planeWidth * 100; //64;
			var DTHeight = planeHeight * 100; //64

			var dynamicTexture = new BABYLON.DynamicTexture("DynamicTexture", {width:DTWidth, height:DTHeight}, currentScene);

			//Check width of text for given font type at any size of font
			var ctx = dynamicTexture.getContext();

			dynamicTexture.hasAlpha = true;
			ctx.fillStyle = 'transparent';

			textureContext = dynamicTexture.getContext();
			textureContext.font = "28px AldoSemiBold";
			textureContext.save();
			textureContext.fillStyle = "#00ccff";

			//wrapText(textureContext, text, 112, 112, 480, 25);
			wrapText(textureContext, text, 5, 20, 475, 25);
			textureContext.restore();
			
			dynamicTexture.update();

			//create material
			var mat = new BABYLON.StandardMaterial("mat", currentScene);
			mat.diffuseTexture = dynamicTexture;
			mat.emissiveColor = new BABYLON.Color3(1, 1, 1);

			//apply material
			plane.material = mat;

			// set the position
			plane.position.x = x;
			plane.position.y = y;
			plane.position.z = z;
			plane.showBoundingBox = false;

			return(plane);
		}

		function getCollisionBox() {
			//Simple box
			var box = new BABYLON.MeshBuilder.CreateBox("collisionBox", {
				width: 100, 
				height: 30,
				depth: 40,
				sideOrientation: 1
			}, currentScene);

			box.position = new BABYLON.Vector3(7.5, 2.5, -19.99);
			//create material
			var mat = new BABYLON.StandardMaterial("mat", currentScene);
			mat.diffuseColor = new BABYLON.Color3(10/255, 80/255, 119/255);
			mat.emissiveColor = new BABYLON.Color3(10/255, 80/255, 119/255);

			//apply material
			box.material = mat;

			return(box);
		}

		function getCamera() {
			// camera
//			var camera = new BABYLON.FreeCamera("FreeCamera", new BABYLON.Vector3(0, 0, -10), currentScene);
			var camera = new BABYLON.FlyCamera("FlyCamera", new BABYLON.Vector3(0, 0, -10), currentScene);
//			var camera = new BABYLON.ArcRotateCamera("Camera", -Math.PI / 2, Math.PI / 2, 2, new BABYLON.Vector3(0, 0, -10), currentScene);			
			camera.rollCorrect = 10;
			camera.bankedTurn = true;
			camera.bankedTurnLimit = Math.PI / 8;
			camera.bankedTurnMultiplier = 1;

			camera.keysLeft.push(37);
			camera.keysUp.push(38);
			camera.keysRight.push(39);
			camera.keysDown.push(40);

			
			camera.keysForward.push(33);
			camera.keysBackward.push(34);

			camera.lowerRadiusLimit = 1;
			camera.upperRadiusLimit = 10;
/*
*/
			camera.acceleration = 0.01;
			camera.speed = 0.5;

			return(camera);
		}

		function circlePoints(points, radius, center) {
			var slice = 2 * Math.PI / points;
			var nodes = [];
			for (var i = 0; i < points; i++) {
				var angle = slice * i;
			    var newX = center.X + radius * Math.cos(angle);
			    var newY = center.Y + radius * Math.sin(angle);

			    nodes.push({x: newX, y: newY});
/*
				var box = new BABYLON.MeshBuilder.CreateBox("box", {
					width: 0.1, 
					height: 0.1,
					depth: 0.1,
					sideOrientation: 1
				}, currentScene);
				box.position = new BABYLON.Vector3(newX, newY, -1);
				//create material
				var mat = new BABYLON.StandardMaterial("mat", currentScene);
				mat.diffuseColor = new BABYLON.Color3(1,.5,0);
				mat.emissiveColor = new BABYLON.Color3(1,.5,0);

				//apply material
				box.material = mat;
*/
			}
			return(nodes);
		}

		var createGenericScene = function() {
			var genericScene = new BABYLON.Scene(engine);

			currentScene = genericScene;
			
			// lights - no light!!
			//var light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 0, -1), genericScene);
			//light.intensity = 0.3;

			genericScene.clearColor = new BABYLON.Color3(10/255, 80/255, 119/255);

			var camera = getCamera();
			camera.attachControl(canvas, true);

			var box = getCollisionBox();

			// Enable Collisions
			box.checkCollisions = true;
			camera.checkCollisions = true;
			genericScene.collisionsEnabled = true;
			
		    // GUI
		    var advancedTexture = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

		    var button = BABYLON.GUI.Button.CreateImageButton("homebutton", "Home", "/nav-top-logo.png");
		    button.width = 0.1;
		    button.height = "40px";
		    button.color = "white";
		    button.name = "homebutton";
		    button.fontFamily = "AldoSemiBold";
		    button.background = "transparent";
            button.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
            button.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
		    advancedTexture.addControl(button); 
		    button.onPointerClickObservable.add((pointerInfo) => {
				currentScene = __topicScene();
				dpt.getTopic();
		    });

			genericScene.onPointerObservable.add((pointerInfo) => {
				switch (pointerInfo.type) {
					case BABYLON.PointerEventTypes.POINTERDOWN:
						//console.log("POINTER DOWN");
						break;
					case BABYLON.PointerEventTypes.POINTERUP:
						//console.log("POINTER UP");
						break;
					case BABYLON.PointerEventTypes.POINTERMOVE:
						//console.log("POINTER MOVE");
						break;
					case BABYLON.PointerEventTypes.POINTERWHEEL:
						//console.log("POINTER WHEEL");
						break;
					case BABYLON.PointerEventTypes.POINTERPICK:
						//console.log("POINTER PICK");
						break;
					case BABYLON.PointerEventTypes.POINTERTAP:
						//console.log("POINTER TAP");

						break;
					case BABYLON.PointerEventTypes.POINTERDOUBLETAP:
						//console.log("POINTER DOUBLE-TAP");

						if('dpt' in pointerInfo.pickInfo.pickedMesh
						&& pointerInfo.pickInfo.pickedMesh.dpt.context == "topicMap") {
							//console.log("hit topicId: "+pointerInfo.pickInfo.pickedMesh.dpt.topicId);

							pointerInfo.pickInfo.pickedMesh.showBoundingBox = true;
							setTimeout(function() {
								pointerInfo.pickInfo.pickedMesh.showBoundingBox = false;
							}, 250);

							currentTopic = pointerInfo.pickInfo.pickedMesh.dpt.topicId;
							currentScene = __opinionScene();
							dpt.getOpinionByTopic(currentTopic);
						}
						break;
		        }
		    });

			genericScene.onKeyboardObservable.add((kbInfo) => {
				switch (kbInfo.type) {
					case BABYLON.KeyboardEventTypes.KEYDOWN:
						//console.log("KEY DOWN: ", kbInfo.event.key);
						break;
					case BABYLON.KeyboardEventTypes.KEYUP:
						//console.log("KEY UP: ", kbInfo.event.keyCode);
						break;
				}
			});

			return genericScene;
	}

//	__createScene = createTopicScene;

	var engine = new BABYLON.Engine(canvas, true); //, { preserveDrawingBuffer: true, stencil: true });
	var currentScene;
	var __topicScene = createGenericScene;
	var __opinionScene = createGenericScene;
	var currentScene = createGenericScene();
	var currentTopic;
	var dpt;

	document.addEventListener("DOMContentLoaded", function(event) {
		var socket = io.connect(
			window.location.protocol + "//" + window.location.host,
			{
				transports: ["websocket"],
			}
		);

		dpt = new DPT(socket);
		var restObj = {};
		var whoami = {
			dptUUID: "",
			user: {},
		};

		// Handle the incomming websocket trafic
		socket.on("connect", () => {
			// if needed, we could keep socket.id somewhere
			if (document.cookie) {
				dpt.userLogin(document.cookie);
			}
		});

		socket.on("private", function(restObj) {
			if (restObj.method == "post") {
				if (restObj.path == "/user/login/") {
					whoami.dptUUID = restObj.data.dptUUID;
					if (restObj.data.message == "logged in") {
						whoami.user = restObj.data.user;
						dpt.getTopic();
					}
					if (restObj.data.message == "user unknown") {
						whoami.user = {};
					}
				}
			}
		});

		socket.on("error", function(e) {
			console.log("System", e ? e : "A unknown error occurred");
			document.location.reload(true);
			window.location.reload(true);
		});

		socket.on("api", function(restObj) {
			if(!restObj || !restObj.path || !restObj.method) {
				return;
			}
			if(restObj.path == '/topic/'
			&& restObj.method == 'get') {
				var options = '';

				var n = Math.floor((Math.sqrt(restObj.data.length)));
				var x = 0 - Math.floor(n/2)*4.8, xstart = x; xmax = (n-1)*4.8;
				var y = ymax = (n-1)*3.2; ystart = ymax; y = ystart;

				for (var i in restObj.data) {
					if(restObj.data[i].user == 'mine') {
						options = '<span class="editTopic" id="'
								+ restObj.data[i]._id
								+ '">&#128393;</span>';
					} else {
						options = '';
					}
					var plane = textBlock(
							x, y, 0,
							`{"context": "topicMap", "topicId": "${restObj.data[i]._id}"}`,
							`${restObj.data[i].content} [ ${restObj.data[i].opinions.length} ]`);
					x+=4.8;
					if(x > xmax) {
						y -= 3.2;
						x=xstart;
					}
/*
					jQuery('div.col.left').append(
						'<li> <a class="opinionlist" id="'
						+ restObj.data[i]._id
						+ '" href="#">'
						+ restObj.data[i].content
						+ "</a>"
						+ ' [' + restObj.data[i].opinions.length + '] '
						+ options+"</li><br>");
*/
				}
				//topicEdit();
				//topicForm();
			} else if(restObj.path == "/opinion/"+currentTopic+"/") {
				var i;
				var options = '';
				var canInvite = false;

				var n = Math.floor((Math.sqrt(restObj.data.length)));
				var x = 0 - Math.floor(n/2)*10, xstart = x; xmax = (n-1)*10;
				var y = ymax = (n-1)*2.5; ystart = ymax; y = ystart;

				var colors = {};
				for(var i in restObj.data) {
					colors[restObj.data[i].topo.opinionId] = restObj.data[i].topo;
				}
				for (var i in restObj.data) {
					if(restObj.data[i].user == 'mine') {
						canInvite = true;
					}
				}

				var nodes = circlePoints(restObj.data.length, 5, {X: 4, Y: 0});
				for (i in restObj.data) {
					options = '';

					if(restObj.data[i].user == 'mine') {
						options = '<span class="editOpinion" id="'
						+ restObj.data[i]._id
						+ '">&#128393;</span>';
					} else {
						if(restObj.data[i].blocked == 0
						&& canInvite) {
							options = '<span class="inviteToDialog" id="'
							+ restObj.data[i]._id
							+ '">'
							+ '&#128172;'
							+ '</span>';
						}
					}

					var plane = textBlock(
							nodes[i].x, nodes[i].y, 0,
							`{"context": "opinionMap", "opinionId": "${restObj.data[i]._id}"}`,
							`${restObj.data[i].content}`);
					/*
					x+=10;
					if(x > xmax) {
						y -= 2.5;
						x=xstart;
					}
					jQuery('div.col.mid').append('<li class="connector" id="'+ restObj.data[i]._id +'"><span class="text">'
					+ restObj.data[i].content
					+ "</span> " +options+ ' <span class="connector" id="'+ restObj.data[i]._id +'"></span></li><br>');
					*/
				}
				
				
				if(restObj.data.length > 0) {
//					dpt.opinionPostAllowed(restObj.data[0].topic);
				} else {
//					opinionForm();
				}
//				opinionEdit();
			}
		});

		//circlePoints(4, 2, {X: 0, Y: 0});

		engine.runRenderLoop(function () {
			if(currentScene) {
				currentScene.render();
			}
		});

		// Resize
		window.addEventListener("resize", function () {
			engine.resize();
		});

	});

	</script>
	</body>
	<script src="https://cdn.socket.io/socket.io-1.2.0.js"></script>
<!-- <script src="https://code.jquery.com/jquery-1.11.1.js"></script> -->
	<script src="dpt-client.js"></script>
</html>
